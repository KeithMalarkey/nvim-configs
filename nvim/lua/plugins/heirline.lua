-- 	"rebelot/heirline.nvim",
-- 	dependencies = { "lewis6991/gitsigns.nvim" },
-- 	config = function()
-- 		vim.diagnostic.config({
-- 			signs = {
-- 				text = {
-- 					[vim.diagnostic.severity.ERROR] = "ÔÅó",
-- 					[vim.diagnostic.severity.WARN] = "ÔÅ±",
-- 					[vim.diagnostic.severity.INFO] = "Û∞ãá",
-- 					[vim.diagnostic.severity.HINT] = "Û∞åµ",
-- 				},
-- 			},
-- 		})

-- 		local conditions = require("heirline.conditions")
-- 		local utils = require("heirline.utils")

-- 		local function setup_colors()
-- 			return {
-- 				bright_bg = utils.get_highlight("Folded").bg,
-- 				bright_fg = utils.get_highlight("Folded").fg,
-- 				red = utils.get_highlight("DiagnosticError").fg,
-- 				dark_red = utils.get_highlight("DiffDelete").bg,
-- 				green = utils.get_highlight("String").fg,
-- 				blue = utils.get_highlight("Function").fg,
-- 				gray = utils.get_highlight("NonText").fg,
-- 				orange = utils.get_highlight("Constant").fg,
-- 				purple = utils.get_highlight("Statement").fg,
-- 				cyan = utils.get_highlight("Special").fg,
-- 				diag_warn = utils.get_highlight("DiagnosticWarn").fg,
-- 				diag_error = utils.get_highlight("DiagnosticError").fg,
-- 				diag_hint = utils.get_highlight("DiagnosticHint").fg,
-- 				diag_info = utils.get_highlight("DiagnosticInfo").fg,
-- 				git_del = utils.get_highlight("diffDeleted").fg,
-- 				git_add = utils.get_highlight("diffAdded").fg,
-- 				git_change = utils.get_highlight("diffChanged").fg,
-- 			}
-- 		end
-- 		local colors = setup_colors()

-- 		-- require("heirline").load_colors(colors)
-- 		-- or pass it to config.opts.colors

-- 		vim.api.nvim_create_augroup("Heirline", { clear = true })
-- 		vim.api.nvim_create_autocmd("ColorScheme", {
-- 			callback = function()
-- 				utils.on_colorscheme(setup_colors)
-- 			end,
-- 			group = "Heirline",
-- 		})

-- 		local ViMode = {
-- 			-- get vim current mode, this information will be required by the provider
-- 			-- and the highlight functions, so we compute it only once per component
-- 			-- evaluation and store it as a component attribute
-- 			init = function(self)
-- 				self.mode = vim.fn.mode(1) -- :h mode()
-- 			end,
-- 			-- Now we define some dictionaries to map the output of mode() to the
-- 			-- corresponding string and color. We can put these into `static` to compute
-- 			-- them at initialisation time.
-- 			static = {
-- 				mode_names = { -- change the strings if you like it vvvvverbose!
-- 					n = "Normal",
-- 					no = "N?",
-- 					nov = "N?",
-- 					noV = "N?",
-- 					["no\22"] = "N?",
-- 					niI = "Ni",
-- 					niR = "Nr",
-- 					niV = "Nv",
-- 					nt = "Nt",
-- 					v = "Visual",
-- 					vs = "Vs",
-- 					V = "V_",
-- 					Vs = "Vs",
-- 					["\22"] = "^V",
-- 					["\22s"] = "^V",
-- 					s = "Select",
-- 					S = "S_",
-- 					["\19"] = "^S",
-- 					i = "Insert",
-- 					ic = "Ic",
-- 					ix = "Ix",
-- 					R = "Replace",
-- 					Rc = "Rc",
-- 					Rx = "Rx",
-- 					Rv = "Rv",
-- 					Rvc = "Rv",
-- 					Rvx = "Rv",
-- 					c = "Command",
-- 					cv = "Ex",
-- 					r = "...",
-- 					rm = "M",
-- 					["r?"] = "?",
-- 					["!"] = "!",
-- 					t = "Terminal",
-- 				},
-- 				mode_colors = {
-- 					n = colors.red,
-- 					i = colors.green,
-- 					v = colors.cyan,
-- 					V = colors.cyan,
-- 					["\22"] = colors.cyan,
-- 					c = colors.orange,
-- 					s = colors.purple,
-- 					S = colors.purple,
-- 					["\19"] = colors.purple,
-- 					R = colors.orange,
-- 					r = colors.orange,
-- 					["!"] = colors.red,
-- 					t = colors.red,
-- 				},
-- 			},
-- 			-- We can now access the value of mode() that, by now, would have been
-- 			-- computed by `init()` and use it to index our strings dictionary.
-- 			-- note how `static` fields become just regular attributes once the
-- 			-- component is instantiated.
-- 			-- To be extra meticulous, we can also add some vim statusline syntax to
-- 			-- control the padding and make sure our string is always at least 2
-- 			-- characters long. Plus a nice Icon.
-- 			provider = function(self)
-- 				return "Ôåå %2(" .. self.mode_names[self.mode] .. "%)"
-- 			end,
-- 			-- Same goes for the highlight. Now the foreground will change according to the current mode.
-- 			hl = function(self)
-- 				local mode = self.mode:sub(1, 1) -- get only the first mode character
-- 				return { fg = self.mode_colors[mode], bold = true }
-- 			end,
-- 			-- Re-evaluate the component only on ModeChanged event!
-- 			-- Also allows the statusline to be re-evaluated when entering operator-pending mode
-- 			update = {
-- 				"ModeChanged",
-- 				pattern = "*:*",
-- 				callback = vim.schedule_wrap(function()
-- 					vim.cmd("redrawstatus")
-- 				end),
-- 			},
-- 		}

-- 		local FileNameBlock = {
-- 			-- let's first set up some attributes needed by this component and its children
-- 			init = function(self)
-- 				self.filename = vim.api.nvim_buf_get_name(0)
-- 			end,
-- 		}

-- 		local FileIcon = {
-- 			init = function(self)
-- 				local filename = self.filename
-- 				local extension = vim.fn.fnamemodify(filename, ":e")
-- 				self.icon, self.icon_color =
-- 					require("nvim-web-devicons").get_icon_color(filename, extension, { default = true })
-- 			end,
-- 			provider = function(self)
-- 				return self.icon and (self.icon .. " ")
-- 			end,
-- 			hl = function(self)
-- 				return { fg = self.icon_color }
-- 			end,
-- 		}

-- 		local FileName = {
-- 			init = function(self)
-- 				self.lfilename = vim.fn.fnamemodify(self.filename, ":.")
-- 				if self.lfilename == "" then
-- 					self.lfilename = "[No Name]"
-- 				end
-- 			end,
-- 			hl = { fg = utils.get_highlight("Directory").fg },

-- 			flexible = 2,

-- 			{
-- 				provider = function(self)
-- 					return self.lfilename
-- 				end,
-- 			},
-- 			{
-- 				provider = function(self)
-- 					return vim.fn.pathshorten(self.lfilename)
-- 				end,
-- 			},
-- 		}

-- 		local FileFlags = {
-- 			{
-- 				condition = function()
-- 					return vim.bo.modified
-- 				end,
-- 				provider = "[+]",
-- 				hl = { fg = colors.green },
-- 			},
-- 			{
-- 				condition = function()
-- 					return not vim.bo.modifiable or vim.bo.readonly
-- 				end,
-- 				provider = "ÔÄ£",
-- 				hl = { fg = colors.orange },
-- 			},
-- 		}

-- 		-- Now, let's say that we want the filename color to change if the buffer is
-- 		-- modified. Of course, we could do that directly using the FileName.hl field,
-- 		-- but we'll see how easy it is to alter existing components using a "modifier"
-- 		-- component

-- 		local FileNameModifer = {
-- 			hl = function()
-- 				if vim.bo.modified then
-- 					-- use `force` because we need to override the child's hl foreground
-- 					return { fg = colors.cyan, bold = true, force = true }
-- 				end
-- 			end,
-- 		}

-- 		-- let's add the children to our FileNameBlock component
-- 		FileNameBlock = utils.insert(
-- 			FileNameBlock,
-- 			FileIcon,
-- 			utils.insert(FileNameModifer, FileName), -- a new table where FileName is a child of FileNameModifier
-- 			FileFlags,
-- 			{ provider = "%<" } -- this means that the statusline is cut here when there's not enough space
-- 		)

-- 		local FileType = {
-- 			provider = function()
-- 				return string.upper(vim.bo.filetype)
-- 			end,
-- 			hl = { fg = utils.get_highlight("Type").fg, bold = true },
-- 		}

-- 		local FileEncoding = {
-- 			provider = function()
-- 				local enc = (vim.bo.fenc ~= "" and vim.bo.fenc) or vim.o.enc -- :h 'enc'
-- 				return enc:upper()
-- 			end,
-- 		}

-- 		local FileFormat = {
-- 			provider = function()
-- 				local fmt = vim.bo.fileformat
-- 				return fmt:upper()
-- 			end,
-- 		}

-- 		-- We're getting minimalist here!
-- 		local Ruler = {
-- 			-- %l = current line number
-- 			-- %L = number of lines in the buffer
-- 			-- %c = column number
-- 			-- %P = percentage through file of displayed window
-- 			provider = "[%l/%L:%2c] %P",
-- 		}

-- 		-- I take no credits for this! ü¶Å
-- 		local ScrollBar = {
-- 			static = {
-- 				-- sbar = { "‚ñÅ", "‚ñÇ", "‚ñÉ", "‚ñÑ", "‚ñÖ", "‚ñÜ", "‚ñá", "‚ñà" },
-- 				-- Another variant, because the more choice the better.
-- 				sbar = { "ü≠∂", "ü≠∑", "ü≠∏", "ü≠π", "ü≠∫", "ü≠ª" },
-- 			},
-- 			provider = function(self)
-- 				local curr_line = vim.api.nvim_win_get_cursor(0)[1]
-- 				local lines = vim.api.nvim_buf_line_count(0)
-- 				local i = math.floor((curr_line - 1) / lines * #self.sbar) + 1
-- 				return string.rep(self.sbar[i], 2)
-- 			end,
-- 			hl = { fg = colors.blue, bg = colors.bright_bg },
-- 		}

-- 		local LSPActive = {
-- 			condition = conditions.lsp_attached,
-- 			update = { "LspAttach", "LspDetach" },

-- 			-- You can keep it simple,
-- 			-- provider = "Ôê£ [LSP]",

-- 			-- Or complicate things a bit and get the servers names
-- 			provider = function()
-- 				local names = {}
-- 				for i, server in pairs(vim.lsp.get_clients({ bufnr = 0 })) do
-- 					table.insert(names, server.name)
-- 				end
-- 				return "Ôê£ [" .. table.concat(names, " ") .. "]"
-- 			end,
-- 			hl = { fg = colors.green, bold = true },
-- 		}

-- 		local Diagnostics = {

-- 			condition = conditions.has_diagnostics,
-- 			-- Fetching custom diagnostic icons
-- 			error_icon = vim.diagnostic.config()["signs"]["text"][vim.diagnostic.severity.ERROR],
-- 			warn_icon = vim.diagnostic.config()["signs"]["text"][vim.diagnostic.severity.WARN],
-- 			info_icon = vim.diagnostic.config()["signs"]["text"][vim.diagnostic.severity.INFO],
-- 			hint_icon = vim.diagnostic.config()["signs"]["text"][vim.diagnostic.severity.HINT],

-- 			-- If you defined custom LSP diagnostics with vim.fn.sign_define(), use this instead
-- 			-- Note defining custom LSP diagnostic this way its deprecated, though
-- 			-- static = {
-- 			-- error_icon = vim.fn.sign_getdefined("DiagnosticSignError")[1].text,
-- 			-- warn_icon = vim.fn.sign_getdefined("DiagnosticSignWarn")[1].text,
-- 			-- info_icon = vim.fn.sign_getdefined("DiagnosticSignInfo")[1].text,
-- 			-- hint_icon = vim.fn.sign_getdefined("DiagnosticSignHint")[1].text,
-- 			-- },

-- 			init = function(self)
-- 				self.errors = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.ERROR })
-- 				self.warnings = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.WARN })
-- 				self.hints = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.HINT })
-- 				self.info = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.INFO })
-- 			end,

-- 			update = { "DiagnosticChanged", "BufEnter" },

-- 			{
-- 				provider = "![",
-- 			},
-- 			{
-- 				provider = function(self)
-- 					-- 0 is just another output, we can decide to print it or not!
-- 					return self.errors > 0 and (self.error_icon .. self.errors .. " ")
-- 				end,
-- 				hl = { fg = colors.diag_error },
-- 			},
-- 			{
-- 				provider = function(self)
-- 					return self.warnings > 0 and (self.warn_icon .. self.warnings .. " ")
-- 				end,
-- 				hl = { fg = colors.diag_warn },
-- 			},
-- 			{
-- 				provider = function(self)
-- 					return self.info > 0 and (self.info_icon .. self.info .. " ")
-- 				end,
-- 				hl = { fg = colors.diag_info },
-- 			},
-- 			{
-- 				provider = function(self)
-- 					return self.hints > 0 and (self.hint_icon .. self.hints)
-- 				end,
-- 				hl = { fg = colors.diag_hint },
-- 			},
-- 			{
-- 				provider = "]",
-- 			},
-- 		}

-- 		local Git = {
-- 			condition = conditions.is_git_repo,

-- 			init = function(self)
-- 				-- ÂÆâÂÖ®Âú∞Ëé∑Âèñ gitsigns Áä∂ÊÄÅ
-- 				self.status_dict = vim.b.gitsigns_status_dict or {}

-- 				-- Â¶ÇÊûú gitsigns Êú™Êèê‰æõÊï∞ÊçÆÔºåÂ∞ùËØïÊâãÂä®Ëé∑Âèñ
-- 				if not self.status_dict.head then
-- 					self.status_dict.head = self:get_git_branch() or ""
-- 					self.status_dict.added = 0
-- 					self.status_dict.removed = 0
-- 					self.status_dict.changed = 0
-- 				end

-- 				self.has_changes = (self.status_dict.added or 0) ~= 0
-- 					or (self.status_dict.removed or 0) ~= 0
-- 					or (self.status_dict.changed or 0) ~= 0
-- 			end,

-- 			-- ËæÖÂä©ÂáΩÊï∞ÔºöÊâãÂä®Ëé∑Âèñ Git ÂàÜÊîØ
-- 			get_git_branch = function(self)
-- 				-- ÊñπÊ≥ï1ÔºöÈÄöËøá git ÂëΩ‰ª§
-- 				local handle = io.popen("git branch --show-current 2>/dev/null")
-- 				if handle then
-- 					local result = handle:read("*a"):gsub("%s+$", "")
-- 					handle:close()
-- 					if result and result ~= "" then
-- 						return result
-- 					end
-- 				end

-- 				-- ÊñπÊ≥ï2ÔºöÈÄöËøá vim ÂáΩÊï∞
-- 				local branch = vim.fn.system("git rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d '\n'")
-- 				if branch and branch ~= "" and not branch:match("fatal:") then
-- 					return branch
-- 				end

-- 				return nil
-- 			end,

-- 			hl = { fg = colors.orange },

-- 			{ -- git branch name
-- 				provider = function(self)
-- 					local head = self.status_dict.head or ""
-- 					if head == "" then
-- 						return "Ôêò (no branch)"
-- 					else
-- 						return "Ôêò " .. head
-- 					end
-- 				end,
-- 				hl = { bold = true },
-- 			},
-- 			-- You could handle delimiters, icons and counts similar to Diagnostics
-- 			{
-- 				condition = function(self)
-- 					return self.has_changes
-- 				end,
-- 				provider = " (",
-- 			},
-- 			{
-- 				provider = function(self)
-- 					local count = self.status_dict.added or 0
-- 					return count > 0 and ("+" .. count)
-- 				end,
-- 				hl = { fg = colors.git_add },
-- 			},
-- 			{
-- 				provider = function(self)
-- 					local count = self.status_dict.removed or 0
-- 					return count > 0 and ("-" .. count)
-- 				end,
-- 				hl = { fg = colors.git_del },
-- 			},
-- 			{
-- 				provider = function(self)
-- 					local count = self.status_dict.changed or 0
-- 					return count > 0 and ("~" .. count)
-- 				end,
-- 				hl = { fg = colors.git_change },
-- 			},
-- 			{
-- 				condition = function(self)
-- 					return self.has_changes
-- 				end,
-- 				provider = ")",
-- 			},
-- 		}

-- 		local WorkDir = {
-- 			init = function(self)
-- 				self.icon = (vim.fn.haslocaldir(0) == 1 and "LocalWSpace" or "GlobalWSpace") .. " " .. "Ôêì "
-- 				local cwd = vim.fn.getcwd(0)
-- 				self.cwd = vim.fn.fnamemodify(cwd, ":~")
-- 			end,
-- 			hl = { fg = colors.blue, bold = true },

-- 			flexible = 1,

-- 			{
-- 				-- evaluates to the full-lenth path
-- 				provider = function(self)
-- 					local trail = self.cwd:sub(-1) == "/" and "" or "/"
-- 					return self.icon .. self.cwd .. trail .. " "
-- 				end,
-- 			},
-- 			{
-- 				-- evaluates to the shortened path
-- 				provider = function(self)
-- 					local cwd = vim.fn.pathshorten(self.cwd)
-- 					local trail = self.cwd:sub(-1) == "/" and "" or "/"
-- 					return self.icon .. cwd .. trail .. " "
-- 				end,
-- 			},
-- 			{
-- 				-- evaluates to "", hiding the component
-- 				provider = "",
-- 			},
-- 		}

-- 		local HelpFileName = {
-- 			condition = function()
-- 				return vim.bo.filetype == "help"
-- 			end,
-- 			provider = function()
-- 				local filename = vim.api.nvim_buf_get_name(0)
-- 				return vim.fn.fnamemodify(filename, ":t")
-- 			end,
-- 			hl = { fg = colors.blue },
-- 		}

-- 		local TerminalName = {
-- 			-- we could add a condition to check that buftype == 'terminal'
-- 			-- or we could do that later (see #conditional-statuslines below)
-- 			provider = function()
-- 				local tname, _ = vim.api.nvim_buf_get_name(0):gsub(".*:", "")
-- 				return "Ôíâ " .. tname
-- 			end,
-- 			hl = { fg = colors.blue, bold = true },
-- 		}

-- 		local Time = {
-- 			provider = function()
-- 				local hour = tonumber(os.date("%H"))
-- 				local icon

-- 				-- Ê†πÊçÆÊó∂Èó¥ÊòæÁ§∫‰∏çÂêåÂõæÊ†á
-- 				if hour >= 6 and hour < 12 then
-- 					icon = "Óçå " -- Êó©Êô®
-- 				elseif hour >= 12 and hour < 18 then
-- 					icon = "Óçç " -- ‰∏ãÂçà
-- 				elseif hour >= 18 and hour < 22 then
-- 					icon = "Óçé " -- Êôö‰∏ä
-- 				else
-- 					icon = "ÓçÖ " -- Â§úÊôö
-- 				end

-- 				return icon .. os.date("%Y-%m-%d %H:%M:%S")
-- 			end,
-- 			hl = { fg = colors.blue, bold = true },
-- 			update = 60000, -- ÊØèÂàÜÈíüÊõ¥Êñ∞‰∏ÄÊ¨°ÔºàÂõæÊ†á‰∏çÈúÄË¶ÅÊØèÁßíÊõ¥Êñ∞Ôºâ
-- 		}

-- 		local Space = { provider = " " }
-- 		local Align = { provider = "%=" }
-- 		local Mid = { provider = "@" }
-- 		local DefaultStatusline = {
-- 			ViMode,
-- 			Space,
-- 			Git,
-- 			Space,
-- 			FileNameBlock,
-- 			Space,
-- 			Diagnostics,
-- 			Align,
-- 			Time,
-- 			Mid,
-- 			Space,
-- 			WorkDir,
-- 			Align,
-- 			LSPActive,
-- 			Space,
-- 			FileType,
-- 			Space,
-- 			FileFormat,
-- 			Space,
-- 			FileEncoding,
-- 			Space,
-- 			Ruler,
-- 			Space,
-- 			ScrollBar,
-- 		}

-- 		local InactiveStatusline = {
-- 			condition = conditions.is_not_active,
-- 			FileType,
-- 			Space,
-- 			FileName,
-- 			Align,
-- 		}

-- 		local SpecialStatusline = {
-- 			condition = function()
-- 				return conditions.buffer_matches({
-- 					buftype = { "nofile", "prompt", "help", "quickfix" },
-- 					filetype = { "^git.*", "fugitive" },
-- 				})
-- 			end,

-- 			FileType,
-- 			Space,
-- 			HelpFileName,
-- 			Align,
-- 		}

-- 		local TerminalStatusline = {
-- 			condition = function()
-- 				return conditions.buffer_matches({ buftype = { "terminal" } })
-- 			end,

-- 			hl = { bg = colors.dark_red },

-- 			-- Quickly add a condition to the ViMode to only show it when buffer is active!
-- 			{ condition = conditions.is_active, ViMode, Space },
-- 			FileType,
-- 			Space,
-- 			TerminalName,
-- 			Align,
-- 		}

-- 		local StatusLines = {

-- 			hl = function()
-- 				if conditions.is_active() then
-- 					return "StatusLine"
-- 				else
-- 					return "StatusLineNC"
-- 				end
-- 			end,

-- 			-- the first statusline with no condition, or which condition returns true is used.
-- 			-- think of it as a switch case with breaks to stop fallthrough.
-- 			fallthrough = false,

-- 			SpecialStatusline,
-- 			TerminalStatusline,
-- 			InactiveStatusline,
-- 			DefaultStatusline,
-- 		}

-- 		require("heirline").setup({
-- 			statusline = { StatusLines },
-- 			winbar = nil,
-- 			tabline = nil,
-- 			statuscolumn = nil,
-- 			opts = { colors = colors },
-- 		})
-- 	end,
-- }
return {}
